---
phase: 04-polish-launch-essentials
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - ToEvent/ToEvent/State/AppState.swift
  - ToEvent/ToEvent/Utilities/UrgencyLevel.swift
  - ToEvent/ToEvent/Services/CalendarService.swift
  - ToEvent/ToEvent/Views/Settings/AdvancedSettingsView.swift
  - ToEvent/ToEvent/Views/EventListView.swift
  - ToEvent/ToEvent/ToEventApp.swift
  - ToEvent/ToEvent.xcodeproj/project.pbxproj
autonomous: true

must_haves:
  truths:
    - "User can customize urgency color thresholds (imminent, soon, approaching)"
    - "User can set calendar fetch interval"
    - "User can configure number of events shown in dropdown"
    - "Fetch interval respects system battery state"
  artifacts:
    - path: "ToEvent/ToEvent/Views/Settings/AdvancedSettingsView.swift"
      provides: "Advanced settings pane"
      contains: "UrgencyThresholds"
    - path: "ToEvent/ToEvent/Utilities/UrgencyLevel.swift"
      provides: "Configurable thresholds"
      contains: "UrgencyThresholds"
  key_links:
    - from: "UrgencyLevel.swift"
      to: "appState.urgencyThresholds"
      via: "threshold lookup"
      pattern: "from.*thresholds"
    - from: "CalendarService.swift"
      to: "appState.fetchInterval"
      via: "background scheduler"
      pattern: "NSBackgroundActivityScheduler"
---

<objective>
Add advanced settings: configurable urgency thresholds, calendar fetch interval, event count limit, and battery optimization.

Purpose: Give power users control over performance and behavior tuning.
Output: AdvancedSettingsView with threshold/interval/count settings, UrgencyLevel updated to accept thresholds, CalendarService with configurable fetch.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-polish-launch-essentials/04-RESEARCH.md

@ToEvent/ToEvent/State/AppState.swift
@ToEvent/ToEvent/Utilities/UrgencyLevel.swift
@ToEvent/ToEvent/Services/CalendarService.swift
@ToEvent/ToEvent/Views/EventListView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add configurable urgency thresholds to UrgencyLevel and AppState</name>
  <files>
    ToEvent/ToEvent/Utilities/UrgencyLevel.swift
    ToEvent/ToEvent/State/AppState.swift
  </files>
  <action>
    Update UrgencyLevel.swift to add UrgencyThresholds struct and parameterized from():

    ```swift
    import AppKit

    struct UrgencyThresholds: Equatable {
        var imminent: TimeInterval  // seconds, default 900 (15 min)
        var soon: TimeInterval      // seconds, default 1800 (30 min)
        var approaching: TimeInterval // seconds, default 3600 (1 hour)

        static let `default` = UrgencyThresholds(
            imminent: 900,
            soon: 1800,
            approaching: 3600
        )

        // Validation: must be ordered imminent < soon < approaching
        var isValid: Bool {
            imminent < soon && soon < approaching
        }
    }

    enum UrgencyLevel: Comparable {
        case normal      // > approaching threshold
        case approaching // <= approaching (yellow)
        case soon        // <= soon (orange)
        case imminent    // <= imminent (red)
        case now         // event started

        // Original method for backward compatibility (uses defaults)
        static func from(secondsRemaining: TimeInterval) -> UrgencyLevel {
            from(secondsRemaining: secondsRemaining, thresholds: .default)
        }

        // New method with configurable thresholds
        static func from(secondsRemaining: TimeInterval, thresholds: UrgencyThresholds) -> UrgencyLevel {
            switch secondsRemaining {
            case ...0: return .now
            case 0..<thresholds.imminent: return .imminent
            case thresholds.imminent..<thresholds.soon: return .soon
            case thresholds.soon..<thresholds.approaching: return .approaching
            default: return .normal
            }
        }

        var color: NSColor {
            switch self {
            case .normal: return .labelColor
            case .approaching: return .systemYellow
            case .soon: return .systemOrange
            case .imminent, .now: return .systemRed
            }
        }

        var iconFilled: Bool {
            self >= .soon
        }
    }
    ```

    Add threshold properties to AppState.swift:

    ```swift
    @Published var urgencyThresholds: UrgencyThresholds {
        didSet {
            UserDefaults.standard.set(urgencyThresholds.imminent, forKey: Keys.urgencyImminent)
            UserDefaults.standard.set(urgencyThresholds.soon, forKey: Keys.urgencySoon)
            UserDefaults.standard.set(urgencyThresholds.approaching, forKey: Keys.urgencyApproaching)
        }
    }
    ```

    Add Keys:
    ```swift
    static let urgencyImminent = "urgencyImminent"
    static let urgencySoon = "urgencySoon"
    static let urgencyApproaching = "urgencyApproaching"
    ```

    Initialize in init():
    ```swift
    let imminent = UserDefaults.standard.double(forKey: Keys.urgencyImminent)
    let soon = UserDefaults.standard.double(forKey: Keys.urgencySoon)
    let approaching = UserDefaults.standard.double(forKey: Keys.urgencyApproaching)

    if imminent > 0 && soon > 0 && approaching > 0 {
        self.urgencyThresholds = UrgencyThresholds(
            imminent: imminent,
            soon: soon,
            approaching: approaching
        )
    } else {
        self.urgencyThresholds = .default
    }
    ```

    Update urgencyLevel computed property to use thresholds:
    ```swift
    var urgencyLevel: UrgencyLevel {
        guard let event = nextEvent else { return .normal }
        let remaining = event.startDate.timeIntervalSince(Date())
        return UrgencyLevel.from(secondsRemaining: remaining, thresholds: urgencyThresholds)
    }
    ```
  </action>
  <verify>
    - Build succeeds
    - UrgencyThresholds.default has imminent=900, soon=1800, approaching=3600
    - UrgencyLevel.from(secondsRemaining: 600, thresholds: .default) returns .imminent
  </verify>
  <done>
    UrgencyThresholds struct added with configurable thresholds.
    UrgencyLevel.from() accepts optional thresholds parameter.
    AppState has urgencyThresholds property that persists to UserDefaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add fetch interval and event count settings to AppState and CalendarService</name>
  <files>
    ToEvent/ToEvent/State/AppState.swift
    ToEvent/ToEvent/Services/CalendarService.swift
    ToEvent/ToEvent/Views/EventListView.swift
  </files>
  <action>
    Add to AppState.swift:

    ```swift
    @Published var fetchInterval: TimeInterval {
        didSet {
            UserDefaults.standard.set(fetchInterval, forKey: Keys.fetchInterval)
            CalendarService.shared.updateFetchInterval(fetchInterval)
        }
    }

    @Published var maxEventsToShow: Int {
        didSet {
            UserDefaults.standard.set(maxEventsToShow, forKey: Keys.maxEventsToShow)
        }
    }
    ```

    Add Keys:
    ```swift
    static let fetchInterval = "fetchInterval"
    static let maxEventsToShow = "maxEventsToShow"
    ```

    Initialize in init():
    ```swift
    let storedFetchInterval = UserDefaults.standard.double(forKey: Keys.fetchInterval)
    self.fetchInterval = storedFetchInterval > 0 ? storedFetchInterval : 300 // Default: 5 minutes

    let storedMaxEvents = UserDefaults.standard.integer(forKey: Keys.maxEventsToShow)
    self.maxEventsToShow = storedMaxEvents > 0 ? storedMaxEvents : 10 // Default: 10 events
    ```

    After init setup, call CalendarService to set initial interval.

    Update CalendarService.swift to add configurable background fetch:

    ```swift
    private var backgroundActivity: NSBackgroundActivityScheduler?
    private var currentFetchInterval: TimeInterval = 300

    func updateFetchInterval(_ interval: TimeInterval) {
        guard interval != currentFetchInterval else { return }
        currentFetchInterval = interval
        restartBackgroundFetch()
    }

    func startBackgroundFetch() {
        restartBackgroundFetch()
    }

    private func restartBackgroundFetch() {
        stopBackgroundFetch()

        backgroundActivity = NSBackgroundActivityScheduler(identifier: "com.toevent.calendarFetch")
        backgroundActivity?.repeats = true
        backgroundActivity?.interval = currentFetchInterval
        backgroundActivity?.tolerance = currentFetchInterval * 0.25 // 25% tolerance for battery
        backgroundActivity?.qualityOfService = .utility

        backgroundActivity?.schedule { [weak self] completion in
            guard let self = self else {
                completion(.finished)
                return
            }

            if self.backgroundActivity?.shouldDefer == true {
                completion(.deferred)
                return
            }

            DispatchQueue.main.async {
                // Trigger refresh via notification
                self.lastRefresh = Date()
                completion(.finished)
            }
        }
    }

    func stopBackgroundFetch() {
        backgroundActivity?.invalidate()
        backgroundActivity = nil
    }
    ```

    Call startBackgroundFetch() in CalendarService init or from AppState after intro.

    Update EventListView.swift to limit events shown:

    In EventListView, the body should respect maxEventsToShow:
    ```swift
    @EnvironmentObject private var appState: AppState

    var body: some View {
        VStack(spacing: 0) {
            if appState.events.isEmpty {
                emptyState
            } else {
                let eventsToShow = Array(appState.timedEvents.prefix(appState.maxEventsToShow))
                ForEach(eventsToShow) { event in
                    EventRowView(event: event) {
                        onEventTap(event)
                    }
                    .environmentObject(appState)
                }
                // ... all-day events section
            }
        }
    }
    ```
  </action>
  <verify>
    - Build succeeds
    - CalendarService has updateFetchInterval method
    - AppState.fetchInterval defaults to 300 (5 min)
    - AppState.maxEventsToShow defaults to 10
    - EventListView shows at most maxEventsToShow events
  </verify>
  <done>
    AppState has fetchInterval and maxEventsToShow properties.
    CalendarService uses NSBackgroundActivityScheduler for energy-efficient background fetch.
    EventListView respects maxEventsToShow limit.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AdvancedSettingsView and register in app</name>
  <files>
    ToEvent/ToEvent/Views/Settings/AdvancedSettingsView.swift
    ToEvent/ToEvent/ToEventApp.swift
    ToEvent/ToEvent.xcodeproj/project.pbxproj
  </files>
  <action>
    Create AdvancedSettingsView.swift:

    ```swift
    import SwiftUI

    struct AdvancedSettingsView: View {
        @EnvironmentObject private var appState: AppState

        private let fetchIntervalOptions: [(String, TimeInterval)] = [
            ("1 minute", 60),
            ("2 minutes", 120),
            ("5 minutes", 300),
            ("10 minutes", 600),
            ("15 minutes", 900),
            ("30 minutes", 1800)
        ]

        private let eventCountOptions = [5, 10, 15, 20, 25]

        var body: some View {
            SettingsContainer(contentWidth: 450) {
                SettingsSection(title: "Urgency Thresholds") {
                    thresholdRow(
                        label: "Red (imminent):",
                        value: $appState.urgencyThresholds.imminent,
                        range: 60...appState.urgencyThresholds.soon - 60
                    )
                    thresholdRow(
                        label: "Orange (soon):",
                        value: $appState.urgencyThresholds.soon,
                        range: appState.urgencyThresholds.imminent + 60...appState.urgencyThresholds.approaching - 60
                    )
                    thresholdRow(
                        label: "Yellow (approaching):",
                        value: $appState.urgencyThresholds.approaching,
                        range: appState.urgencyThresholds.soon + 60...7200
                    )

                    Button("Reset to Defaults") {
                        appState.urgencyThresholds = .default
                    }
                    .buttonStyle(.link)
                }

                SettingsSection(title: "Calendar Sync") {
                    Picker("Fetch interval:", selection: $appState.fetchInterval) {
                        ForEach(fetchIntervalOptions, id: \.1) { option in
                            Text(option.0).tag(option.1)
                        }
                    }
                    .pickerStyle(.menu)

                    Text("More frequent fetching uses more battery")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }

                SettingsSection(title: "Event List") {
                    Picker("Maximum events:", selection: $appState.maxEventsToShow) {
                        ForEach(eventCountOptions, id: \.self) { count in
                            Text("\(count) events").tag(count)
                        }
                    }
                    .pickerStyle(.menu)
                }
            }
        }

        private func thresholdRow(label: String, value: Binding<TimeInterval>, range: ClosedRange<TimeInterval>) -> some View {
            HStack {
                Text(label)
                    .frame(width: 150, alignment: .leading)
                Stepper(
                    formatMinutes(value.wrappedValue),
                    value: value,
                    in: range,
                    step: 60
                )
            }
        }

        private func formatMinutes(_ seconds: TimeInterval) -> String {
            let minutes = Int(seconds / 60)
            if minutes >= 60 {
                let hours = minutes / 60
                let mins = minutes % 60
                return mins > 0 ? "\(hours)h \(mins)m" : "\(hours)h"
            }
            return "\(minutes)m"
        }
    }

    extension AdvancedSettingsView {
        static let pane: SettingsPane = SettingsPane(
            identifier: SettingsPaneIdentifier("advanced"),
            title: "Advanced",
            toolbarIcon: NSImage(systemSymbolName: "gearshape.2", accessibilityDescription: "Advanced")!
        ) {
            AdvancedSettingsView()
        }
    }
    ```

    Update ToEventApp.swift to register AdvancedSettingsView:
    ```swift
    SwiftUI.Settings {
        GeneralSettingsView()
            .environmentObject(appState)
        DisplaySettingsView()
            .environmentObject(appState)
        CalendarSettingsView()
            .environmentObject(appState)
        AdvancedSettingsView()
            .environmentObject(appState)
    }
    ```

    Note: DisplaySettingsView is from plan 04-02. If running in parallel, just add AdvancedSettingsView.
    Final order: General > Display > Calendar > Advanced

    Add AdvancedSettingsView.swift to Xcode project sources.
  </action>
  <verify>
    - Build succeeds
    - Settings shows Advanced pane
    - Urgency threshold steppers work and validate ranges
    - Reset to Defaults button resets thresholds
    - Fetch interval picker changes CalendarService behavior
    - Max events picker limits dropdown list
  </verify>
  <done>
    AdvancedSettingsView created with urgency thresholds, fetch interval, and max events settings.
    Thresholds have validation to maintain ordering.
    All settings persist and take effect immediately.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. Build: `xcodebuild -project ToEvent/ToEvent.xcodeproj -scheme ToEvent build`
2. Run app
3. Open Settings > Advanced
4. Test urgency thresholds:
   - Change imminent to 10m, soon to 20m, approaching to 45m
   - Verify menu bar color changes at new thresholds
   - Verify "Reset to Defaults" works
5. Test fetch interval:
   - Set to 1 minute
   - Observe calendar refreshes more frequently (check via Console.app or debug log)
6. Test max events:
   - Set to 5
   - Verify dropdown shows max 5 events even if more exist
</verification>

<success_criteria>
- CUST-03 complete: Urgency color thresholds configurable
- CUST-05 complete: Calendar fetch interval configurable
- CUST-06 complete: Number of events configurable
- SYST-05 complete: Battery optimization via NSBackgroundActivityScheduler with tolerance
- All settings persist across app restarts
- Threshold validation prevents invalid combinations
</success_criteria>

<output>
After completion, create `.planning/phases/04-polish-launch-essentials/04-03-SUMMARY.md`
</output>
