---
phase: 02-live-countdown-urgency
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - ToEvent/ToEvent/State/AppState.swift
  - ToEvent/ToEvent/ToEventApp.swift
  - ToEvent/ToEvent/Views/MenuBarView.swift
  - ToEvent/ToEvent/Utilities/AdaptiveSchedule.swift
autonomous: false

must_haves:
  truths:
    - "Menu bar countdown updates every second when within 5 minutes of event"
    - "Menu bar text color changes to yellow at 1h, orange at 30m, red at 15m"
    - "Menu bar icon switches from outline to filled when urgent"
    - "Timer pauses when screen is locked, resumes when unlocked"
    - "Calendar color dot appears next to event title in menu bar"
  artifacts:
    - path: "ToEvent/ToEvent/Utilities/AdaptiveSchedule.swift"
      provides: "Custom TimelineSchedule for adaptive updates"
      exports: ["AdaptiveCountdownSchedule"]
    - path: "ToEvent/ToEvent/State/AppState.swift"
      provides: "Extended with urgency level computation"
      contains: "urgencyLevel"
    - path: "ToEvent/ToEvent/ToEventApp.swift"
      provides: "MenuBarExtraAccess integration for colored text"
      contains: "menuBarExtraAccess"
  key_links:
    - from: "ToEvent/ToEvent/ToEventApp.swift"
      to: "NSStatusItem.button.attributedTitle"
      via: "menuBarExtraAccess callback"
      pattern: "attributedTitle"
    - from: "ToEvent/ToEvent/State/AppState.swift"
      to: "SystemStateService"
      via: "Combine subscription"
      pattern: "SystemStateService.shared"
---

<objective>
Implement live countdown display with urgency-based colored text in the menu bar. Timer updates adaptively (1s when close, 60s otherwise) and pauses when screen is locked. Includes calendar color indicator.

Purpose: Core Phase 2 deliverable - the differentiating feature that makes ToEvent useful. Users see real-time countdown with escalating visual urgency.
Output: Working colored countdown in menu bar, adaptive update schedule, screen lock pause/resume, calendar color dot
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-live-countdown-urgency/02-CONTEXT.md
@.planning/phases/02-live-countdown-urgency/02-RESEARCH.md
@.planning/phases/02-live-countdown-urgency/02-01-SUMMARY.md

# Existing code to modify
@ToEvent/ToEvent/State/AppState.swift
@ToEvent/ToEvent/ToEventApp.swift
@ToEvent/ToEvent/Views/MenuBarView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AdaptiveSchedule and extend AppState with urgency and screen lock</name>
  <files>
    ToEvent/ToEvent/Utilities/AdaptiveSchedule.swift
    ToEvent/ToEvent/State/AppState.swift
  </files>
  <action>
Create AdaptiveSchedule.swift with custom TimelineSchedule:
```swift
import SwiftUI

struct AdaptiveCountdownSchedule: TimelineSchedule {
    let eventDate: Date
    let secondsThreshold: TimeInterval

    init(eventDate: Date, secondsThreshold: TimeInterval = 300) {
        self.eventDate = eventDate
        self.secondsThreshold = secondsThreshold
    }

    func entries(from startDate: Date, mode: TimelineScheduleMode) -> Entries {
        Entries(eventDate: eventDate, secondsThreshold: secondsThreshold, startDate: startDate)
    }

    struct Entries: Sequence, IteratorProtocol {
        let eventDate: Date
        let secondsThreshold: TimeInterval
        var current: Date

        init(eventDate: Date, secondsThreshold: TimeInterval, startDate: Date) {
            self.eventDate = eventDate
            self.secondsThreshold = secondsThreshold
            self.current = startDate
        }

        mutating func next() -> Date? {
            guard current < eventDate.addingTimeInterval(60) else { return nil }

            let distance = eventDate.timeIntervalSince(current)
            let interval: TimeInterval = distance <= secondsThreshold ? 1 : 60

            let entry = current
            current = current.addingTimeInterval(interval)
            return entry
        }
    }
}
```

Modify AppState.swift:
1. Add `import AppKit`
2. Add `@Published private(set) var isScreenLocked = false`
3. Add computed property:
```swift
var urgencyLevel: UrgencyLevel {
    guard let event = nextEvent else { return .normal }
    let remaining = event.startDate.timeIntervalSince(Date())
    return UrgencyLevel.from(secondsRemaining: remaining)
}
```
4. In init(), call `observeScreenLock()`
5. Remove `startMenuBarTimer()` call and `menuBarTimer` property (TimelineView will drive updates)
6. Add method:
```swift
private func observeScreenLock() {
    SystemStateService.shared.$isScreenLocked
        .receive(on: DispatchQueue.main)
        .assign(to: &$isScreenLocked)
}
```
7. Update `updateMenuBarTitle()` to use `formatHybridCountdown` instead of `formatRelativeTime`
  </action>
  <verify>
Build project: `xcodebuild -project ToEvent/ToEvent.xcodeproj -scheme ToEvent build`
Check AppState compiles with urgencyLevel property and screen lock observation.
  </verify>
  <done>
AdaptiveCountdownSchedule exists and compiles.
AppState.urgencyLevel returns correct UrgencyLevel based on next event.
AppState.isScreenLocked reflects SystemStateService state.
menuBarTitle uses hybrid countdown format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate MenuBarExtraAccess for colored text with calendar color indicator</name>
  <files>
    ToEvent/ToEvent/ToEventApp.swift
    ToEvent/ToEvent/Views/MenuBarView.swift
  </files>
  <action>
Modify ToEventApp.swift:

1. Add import:
```swift
import MenuBarExtraAccess
```

2. Add state property:
```swift
@State private var isMenuPresented = false
```

3. Add `.menuBarExtraAccess(isPresented: $isMenuPresented)` modifier to MenuBarExtra:
```swift
.menuBarExtraAccess(isPresented: $isMenuPresented) { statusItem in
    updateStatusItemAppearance(statusItem)
}
```

4. Add helper function (note: Event.calendarColor is non-optional CGColor):
```swift
private func updateStatusItemAppearance(_ statusItem: NSStatusItem) {
    let urgency = appState.urgencyLevel
    let title = appState.menuBarTitle

    guard title != "ToEvent", let event = appState.nextEvent else {
        statusItem.button?.title = ""
        statusItem.button?.image = NSImage(systemSymbolName: "calendar", accessibilityDescription: "ToEvent")
        return
    }

    // Build attributed string: [calendar color dot] [countdown text]
    let attributedTitle = NSMutableAttributedString()

    // Calendar color dot (event.calendarColor is CGColor, always present)
    let dotAttachment = NSTextAttachment()
    let dotImage = NSImage(size: NSSize(width: 8, height: 8), flipped: false) { rect in
        NSColor(cgColor: event.calendarColor)?.setFill()
        NSBezierPath(ovalIn: rect.insetBy(dx: 1, dy: 1)).fill()
        return true
    }
    dotAttachment.image = dotImage
    attributedTitle.append(NSAttributedString(attachment: dotAttachment))
    attributedTitle.append(NSAttributedString(string: " "))

    // Countdown text with urgency color
    let textAttributes: [NSAttributedString.Key: Any] = [
        .foregroundColor: urgency.color,
        .font: NSFont.monospacedDigitSystemFont(ofSize: 12, weight: .regular)
    ]
    attributedTitle.append(NSAttributedString(string: title, attributes: textAttributes))

    statusItem.button?.attributedTitle = attributedTitle

    // Icon with urgency variant
    let symbolName = urgency.iconFilled ? "calendar.circle.fill" : "calendar"
    if let image = NSImage(systemSymbolName: symbolName, accessibilityDescription: "ToEvent") {
        if urgency >= .approaching {
            image.isTemplate = false
            let config = NSImage.SymbolConfiguration(paletteColors: [urgency.color])
            statusItem.button?.image = image.withSymbolConfiguration(config)
        } else {
            image.isTemplate = true
            statusItem.button?.image = image
        }
    }
}
```

5. Replace MenuBarExtra label: closure with TimelineView-driven updates:
```swift
label: {
    TimelineView(makeSchedule()) { context in
        // Invisible view that forces refresh on schedule
        Color.clear
            .frame(width: 1, height: 1)
            .opacity(0)
    }
}

private func makeSchedule() -> some TimelineSchedule {
    if appState.isScreenLocked {
        return PeriodicTimelineSchedule(from: .now, by: 3600) // Paused
    }
    if let event = appState.nextEvent {
        return AdaptiveCountdownSchedule(eventDate: event.startDate)
    }
    return PeriodicTimelineSchedule(from: .now, by: 60)
}
```

Note: If TimelineSchedule type erasure is problematic, use @ViewBuilder with conditional views returning different TimelineView instances instead.

Update MenuBarView.swift: Ensure dropdown also uses formatHybridCountdown for countdown display consistency.
  </action>
  <verify>
Build and run: `xcodebuild -project ToEvent/ToEvent.xcodeproj -scheme ToEvent build`
Launch app, observe:
1. Menu bar text shows countdown (e.g., "2h 15m" or "4m 32s")
2. Small colored dot appears before countdown (calendar's color)
3. Text color changes when event is within 1h/30m/15m
4. Icon changes from outline to filled when urgent
  </verify>
  <done>
MenuBarExtraAccess integrated.
Menu bar displays calendar color dot followed by colored countdown text.
Icon changes based on urgency level.
Updates are adaptive (1s when close, 60s otherwise).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Live countdown with urgency-based colored text in menu bar:
- Countdown updates every second when within 5 minutes
- Calendar color dot appears next to countdown
- Text color: yellow at 1h, orange at 30m, red at 15m
- Icon: outline when distant, filled when urgent
- Timer pauses when screen locked
  </what-built>
  <how-to-verify>
**Functional Verification:**
1. Launch ToEvent from Xcode or build output
2. Ensure you have an upcoming calendar event within the next few hours
3. Observe menu bar:
   - Colored dot appears matching the event's calendar color
   - If event > 1h away: white/black text (system default), outline calendar icon
   - If event within 1h: yellow text
   - If event within 30m: orange text
   - If event within 15m: red text, filled calendar icon
4. If event is within 5 minutes, observe countdown showing seconds (e.g., "4m 32s")
5. Watch for 10+ seconds to confirm per-second updates when close
6. Lock screen (Ctrl+Cmd+Q), wait 10 seconds, unlock - countdown should have paused during lock

**Battery Validation (Required):**
7. Open Activity Monitor (Applications > Utilities > Activity Monitor)
8. Find "ToEvent" in the process list
9. With event > 5 minutes away, observe CPU usage over 30 seconds
   - PASS: CPU usage averages < 0.5% (minute-based updates)
10. With event < 5 minutes away, observe CPU usage over 30 seconds
    - PASS: CPU usage averages < 2% (second-based updates)
11. If CPU exceeds these thresholds, note the observed values

Note: Exact percentages may vary by machine. The key test is that minute-mode uses significantly less CPU than second-mode, and neither causes visible battery drain.
  </how-to-verify>
  <resume-signal>Type "approved" with battery validation results, or describe any issues with the countdown display, colors, calendar dot, or battery impact</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. Project builds without errors
2. Menu bar shows calendar color dot followed by colored countdown text
3. Icon switches between outline and filled based on urgency
4. Countdown shows seconds precision when within 5 minutes
5. Updates pause when screen is locked
6. Battery impact validated via Activity Monitor
7. Human verification confirms expected behavior
</verification>

<success_criteria>
- TimelineView drives adaptive updates (1s when <= 5min, 60s otherwise)
- AppState.urgencyLevel correctly classifies events by time remaining
- NSAttributedString with calendar color dot and urgency-colored text set via MenuBarExtraAccess
- Icon variant (calendar vs calendar.circle.fill) reflects urgency
- isScreenLocked pauses TimelineView schedule when true
- Dropdown MenuBarView also uses hybrid countdown format
- Battery impact validated: < 0.5% CPU at minute-mode, < 2% CPU at second-mode
- Human confirms visual behavior matches specification
</success_criteria>

<output>
After completion, create `.planning/phases/02-live-countdown-urgency/02-02-SUMMARY.md`
</output>
