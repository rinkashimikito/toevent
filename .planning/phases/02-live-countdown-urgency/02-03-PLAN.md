---
phase: 02-live-countdown-urgency
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - ToEvent/ToEvent/State/AppState.swift
  - ToEvent/ToEvent/Services/CalendarService.swift
  - ToEvent/ToEvent/Views/Settings/CalendarSettingsView.swift
autonomous: true

must_haves:
  truths:
    - "User can reorder calendars in settings to set priority"
    - "When events start at the same time, higher priority calendar event shows"
    - "Calendar priority persists across app restarts"
  artifacts:
    - path: "ToEvent/ToEvent/State/AppState.swift"
      provides: "Calendar priority storage"
      contains: "calendarPriority"
    - path: "ToEvent/ToEvent/Services/CalendarService.swift"
      provides: "Priority-based event selection"
      contains: "calendarPriority"
    - path: "ToEvent/ToEvent/Views/Settings/CalendarSettingsView.swift"
      provides: "Reorderable calendar list"
      contains: "onMove"
  key_links:
    - from: "ToEvent/ToEvent/Services/CalendarService.swift"
      to: "UserDefaults calendarPriority"
      via: "Priority lookup during event selection"
      pattern: "calendarPriority"
---

<objective>
Add calendar priority ordering for overlapping events. Users can reorder calendars in settings to determine which event displays when multiple events start at the same time.

Purpose: Overlapping events are common (work + personal calendars). Without priority, the displayed event is arbitrary. Users need control.
Output: Reorderable calendar list in settings, priority-based event selection in CalendarService
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-live-countdown-urgency/02-CONTEXT.md
@.planning/phases/02-live-countdown-urgency/02-RESEARCH.md
@.planning/phases/02-live-countdown-urgency/02-01-SUMMARY.md

# Existing code to modify
@ToEvent/ToEvent/State/AppState.swift
@ToEvent/ToEvent/Services/CalendarService.swift
@ToEvent/ToEvent/Views/Settings/CalendarSettingsView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add calendar priority storage to AppState</name>
  <files>ToEvent/ToEvent/State/AppState.swift</files>
  <action>
Add calendarPriority storage to AppState:

```swift
// Add to Keys enum
static let calendarPriority = "calendarPriority"

// Add published property
@Published var calendarPriority: [String] {
    didSet {
        UserDefaults.standard.set(calendarPriority, forKey: Keys.calendarPriority)
    }
}

// In init(), load from UserDefaults:
self.calendarPriority = UserDefaults.standard.stringArray(forKey: Keys.calendarPriority) ?? []
```

The array stores calendar IDs in priority order. First element = highest priority.
Empty array or calendars not in array = lowest priority (sorted after all prioritized calendars).

Add method to initialize priority when new calendars are added:
```swift
func initializeCalendarPriority(with calendars: [CalendarInfo]) {
    // Add any calendars not in priority list to the end
    let existingIDs = Set(calendarPriority)
    let newCalendars = calendars.filter { !existingIDs.contains($0.id) }
    if !newCalendars.isEmpty {
        calendarPriority.append(contentsOf: newCalendars.map { $0.id })
    }
}
```
  </action>
  <verify>
Build project to confirm compilation.
Check that calendarPriority property exists on AppState.
  </verify>
  <done>
AppState has calendarPriority array persisted to UserDefaults.
initializeCalendarPriority method adds new calendars to priority list.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CalendarService to use priority for overlapping events</name>
  <files>ToEvent/ToEvent/Services/CalendarService.swift</files>
  <action>
Modify fetchUpcomingEvents to accept priority parameter and use it for tie-breaking:

```swift
func fetchUpcomingEvents(from calendarIDs: [String]?, lookahead: TimeInterval, priority: [String] = []) -> [Event] {
    let now = Date()
    let endDate = now.addingTimeInterval(lookahead)

    let calendars: [EKCalendar]?
    if let calendarIDs = calendarIDs {
        calendars = calendarIDs.compactMap { id in
            store.calendar(withIdentifier: id)
        }
    } else {
        calendars = nil
    }

    let predicate = store.predicateForEvents(
        withStart: now,
        end: endDate,
        calendars: calendars
    )

    let ekEvents = store.events(matching: predicate)

    // Sort by start time, then by priority for same start time
    return ekEvents
        .sorted { a, b in
            if a.startDate != b.startDate {
                return a.startDate < b.startDate
            }
            // Same start time - use priority
            let aIndex = priority.firstIndex(of: a.calendar?.calendarIdentifier ?? "") ?? Int.max
            let bIndex = priority.firstIndex(of: b.calendar?.calendarIdentifier ?? "") ?? Int.max
            return aIndex < bIndex
        }
        .map { Event(from: $0) }
}
```

This ensures that when multiple events have the same start time, the one from a higher-priority calendar appears first in the array (and thus shows in the menu bar).
  </action>
  <verify>
Build project to confirm compilation.
Check that fetchUpcomingEvents now has priority parameter.
  </verify>
  <done>
CalendarService.fetchUpcomingEvents accepts priority parameter.
Events with same start time are sorted by calendar priority.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update AppState.refreshEvents to pass priority and update CalendarSettingsView with reordering</name>
  <files>
    ToEvent/ToEvent/State/AppState.swift
    ToEvent/ToEvent/Views/Settings/CalendarSettingsView.swift
  </files>
  <action>
In AppState.refreshEvents(), pass calendarPriority to CalendarService:

```swift
func refreshEvents() {
    let calendarIDs = enabledCalendarIDs.map { Array($0) }
    let events = CalendarService.shared.fetchUpcomingEvents(
        from: calendarIDs,
        lookahead: lookahead,
        priority: calendarPriority
    )
    nextEvent = events.first
}
```

Update CalendarSettingsView.swift to support drag-and-drop reordering:

```swift
import SwiftUI

struct CalendarSettingsView: View {
    @EnvironmentObject private var appState: AppState
    @State private var calendars: [CalendarInfo] = []

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Calendars")
                .font(.headline)

            Text("Drag to reorder. Higher calendars have priority when events overlap.")
                .font(.caption)
                .foregroundStyle(.secondary)

            List {
                ForEach(sortedCalendars) { calendar in
                    CalendarRow(calendar: calendar, isEnabled: isCalendarEnabled(calendar.id)) {
                        toggleCalendar(calendar.id)
                    }
                }
                .onMove(perform: moveCalendar)
            }
            .listStyle(.inset)
        }
        .padding()
        .frame(width: 400, height: 400)
        .onAppear {
            loadCalendars()
        }
    }

    private var sortedCalendars: [CalendarInfo] {
        // Sort calendars by priority order
        calendars.sorted { a, b in
            let aIndex = appState.calendarPriority.firstIndex(of: a.id) ?? Int.max
            let bIndex = appState.calendarPriority.firstIndex(of: b.id) ?? Int.max
            return aIndex < bIndex
        }
    }

    private func isCalendarEnabled(_ id: String) -> Bool {
        guard let enabledIDs = appState.enabledCalendarIDs else { return true }
        return enabledIDs.contains(id)
    }

    private func toggleCalendar(_ id: String) {
        if appState.enabledCalendarIDs == nil {
            // First toggle - enable all except this one
            let allIDs = Set(calendars.map { $0.id })
            appState.enabledCalendarIDs = allIDs.subtracting([id])
        } else if var enabled = appState.enabledCalendarIDs {
            if enabled.contains(id) {
                enabled.remove(id)
            } else {
                enabled.insert(id)
            }
            appState.enabledCalendarIDs = enabled
        }
        appState.refreshEvents()
    }

    private func moveCalendar(from source: IndexSet, to destination: Int) {
        // Get current sorted order
        var ordered = sortedCalendars.map { $0.id }
        ordered.move(fromOffsets: source, toOffset: destination)
        appState.calendarPriority = ordered
        appState.refreshEvents()
    }

    private func loadCalendars() {
        calendars = CalendarService.shared.getCalendars()
        appState.initializeCalendarPriority(with: calendars)
    }
}

struct CalendarRow: View {
    let calendar: CalendarInfo
    let isEnabled: Bool
    let onToggle: () -> Void

    var body: some View {
        HStack {
            Circle()
                .fill(Color(cgColor: calendar.color))
                .frame(width: 12, height: 12)

            VStack(alignment: .leading) {
                Text(calendar.title)
                Text(calendar.source)
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }

            Spacer()

            Toggle("", isOn: Binding(
                get: { isEnabled },
                set: { _ in onToggle() }
            ))
            .toggleStyle(.switch)
        }
    }
}
```

Note: The existing CalendarSettingsView structure should be preserved where possible - just add the onMove and sorting logic.
  </action>
  <verify>
Build and run the app.
Open Settings > Calendars tab.
Drag a calendar row up or down - it should reorder.
Close and reopen settings - order should persist.
  </verify>
  <done>
CalendarSettingsView displays calendars in priority order.
User can drag to reorder calendars.
Priority is saved to UserDefaults and persists.
refreshEvents uses priority for event selection.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Project builds without errors
2. AppState.calendarPriority stores and persists calendar order
3. CalendarService.fetchUpcomingEvents uses priority for tie-breaking
4. CalendarSettingsView supports drag-and-drop reordering
5. Priority persists across app restart
</verification>

<success_criteria>
- calendarPriority array is stored in UserDefaults
- New calendars are automatically added to priority list
- fetchUpcomingEvents sorts same-start-time events by priority
- CalendarSettingsView shows calendars in priority order
- Drag-and-drop reordering updates priority
- After reordering, refreshEvents reflects new priority
- Priority persists after closing and reopening app
</success_criteria>

<output>
After completion, create `.planning/phases/02-live-countdown-urgency/02-03-SUMMARY.md`
</output>
