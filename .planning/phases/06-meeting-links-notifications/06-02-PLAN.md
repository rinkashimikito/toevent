---
phase: 06-meeting-links-notifications
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ToEvent/ToEvent/Services/NotificationService.swift
  - ToEvent/ToEvent/ToEventApp.swift
  - ToEvent/ToEvent.entitlements
autonomous: true

must_haves:
  truths:
    - "App can request notification permission from user"
    - "Notifications can be scheduled for future events"
    - "Notification categories with snooze actions are registered"
    - "Delegate handles notification responses"
    - "Custom notification sounds are supported"
  artifacts:
    - path: "ToEvent/ToEvent/Services/NotificationService.swift"
      provides: "UNUserNotificationCenter wrapper with snooze support"
      exports: ["NotificationService"]
      min_lines: 80
    - path: "ToEvent/ToEvent.entitlements"
      provides: "Notification entitlement if needed"
  key_links:
    - from: "ToEventApp.swift"
      to: "NotificationService.swift"
      via: "setup() called on app launch"
      pattern: "NotificationService.shared.setup()"
---

<objective>
Create NotificationService with UNUserNotificationCenter for scheduling event reminders with snooze action support.

Purpose: Foundation for notification features (NOTF-01 through NOTF-05). The service handles permissions, scheduling, and snooze actions.
Output: NotificationService singleton with permission flow, category registration, and delegate handling
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-meeting-links-notifications/06-RESEARCH.md
@ToEvent/ToEvent/ToEventApp.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationService with UNUserNotificationCenter</name>
  <files>ToEvent/ToEvent/Services/NotificationService.swift</files>
  <action>
Create NotificationService singleton:

```swift
import Foundation
import UserNotifications
import Combine

enum NotificationError: Error {
    case permissionDenied
    case schedulingFailed(Error)
}

/// Sound options for notifications - matches AppState.NotificationSoundOption
enum NotificationSoundOption: String {
    case `default` = "default"
    case subtle = "subtle"
    case urgent = "urgent"
    case none = "none"

    var unNotificationSound: UNNotificationSound? {
        switch self {
        case .default:
            return .default
        case .subtle:
            // Use a quieter system sound
            return UNNotificationSound(named: UNNotificationSoundName("Blow"))
        case .urgent:
            // Use a more attention-grabbing sound
            return UNNotificationSound(named: UNNotificationSoundName("Glass"))
        case .none:
            return nil
        }
    }
}

final class NotificationService: NSObject, ObservableObject, UNUserNotificationCenterDelegate {
    static let shared = NotificationService()

    private let center = UNUserNotificationCenter.current()

    @Published private(set) var isAuthorized = false
    @Published private(set) var authorizationStatus: UNAuthorizationStatus = .notDetermined

    // Category identifiers
    static let eventReminderCategory = "EVENT_REMINDER"

    // Action identifiers
    static let snooze3Action = "SNOOZE_3"
    static let snooze5Action = "SNOOZE_5"
    static let snooze10Action = "SNOOZE_10"
    static let joinMeetingAction = "JOIN_MEETING"
    static let dismissAction = UNNotificationDismissActionIdentifier

    private override init() {
        super.init()
    }

    // MARK: - Setup

    func setup() {
        center.delegate = self
        registerCategories()
        Task {
            await checkAuthorizationStatus()
        }
    }

    private func registerCategories() {
        let snooze3 = UNNotificationAction(
            identifier: Self.snooze3Action,
            title: "3 min",
            options: []
        )
        let snooze5 = UNNotificationAction(
            identifier: Self.snooze5Action,
            title: "5 min",
            options: []
        )
        let snooze10 = UNNotificationAction(
            identifier: Self.snooze10Action,
            title: "10 min",
            options: []
        )
        let join = UNNotificationAction(
            identifier: Self.joinMeetingAction,
            title: "Join Meeting",
            options: [.foreground]
        )

        let category = UNNotificationCategory(
            identifier: Self.eventReminderCategory,
            actions: [join, snooze3, snooze5, snooze10],
            intentIdentifiers: [],
            options: [.customDismissAction]
        )

        center.setNotificationCategories([category])
    }

    // MARK: - Authorization

    @MainActor
    private func checkAuthorizationStatus() async {
        let settings = await center.notificationSettings()
        authorizationStatus = settings.authorizationStatus
        isAuthorized = settings.authorizationStatus == .authorized
    }

    func requestPermission() async throws -> Bool {
        let options: UNAuthorizationOptions = [.alert, .sound, .badge]
        let granted = try await center.requestAuthorization(options: options)

        await MainActor.run {
            isAuthorized = granted
            authorizationStatus = granted ? .authorized : .denied
        }

        return granted
    }

    // MARK: - Scheduling

    /// Schedule a reminder for an event
    /// - Parameters:
    ///   - event: The event to remind about
    ///   - minutesBefore: How many minutes before the event to trigger
    ///   - soundOption: The sound preference (default, subtle, urgent, none)
    func scheduleReminder(
        for event: Event,
        minutesBefore: Int,
        soundOption: NotificationSoundOption = .default
    ) async throws {
        guard isAuthorized else {
            throw NotificationError.permissionDenied
        }

        let content = UNMutableNotificationContent()
        content.title = event.title
        content.body = "Starting in \(minutesBefore) minute\(minutesBefore == 1 ? "" : "s")"
        content.sound = soundOption.unNotificationSound
        content.categoryIdentifier = Self.eventReminderCategory
        content.userInfo = [
            "eventId": event.id,
            "meetingURL": event.meetingURL?.absoluteString ?? ""
        ]

        let triggerDate = event.startDate.addingTimeInterval(-Double(minutesBefore * 60))

        // Don't schedule if trigger time is in the past
        guard triggerDate > Date() else { return }

        let components = Calendar.current.dateComponents(
            [.year, .month, .day, .hour, .minute, .second],
            from: triggerDate
        )
        let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)

        let request = UNNotificationRequest(
            identifier: "event-\(event.id)",
            content: content,
            trigger: trigger
        )

        do {
            try await center.add(request)
        } catch {
            throw NotificationError.schedulingFailed(error)
        }
    }

    func cancelReminder(for eventId: String) {
        center.removePendingNotificationRequests(withIdentifiers: ["event-\(eventId)"])
    }

    func cancelAllReminders() {
        center.removeAllPendingNotificationRequests()
    }

    // MARK: - Snooze

    private func reschedule(eventId: String?, meetingURL: String?, minutes: Int) {
        guard let eventId = eventId else { return }

        let content = UNMutableNotificationContent()
        content.title = "Event Reminder (Snoozed)"
        content.body = "Your event is starting soon"
        content.sound = .default
        content.categoryIdentifier = Self.eventReminderCategory
        content.userInfo = [
            "eventId": eventId,
            "meetingURL": meetingURL ?? ""
        ]

        let trigger = UNTimeIntervalNotificationTrigger(
            timeInterval: Double(minutes * 60),
            repeats: false
        )

        let request = UNNotificationRequest(
            identifier: "event-\(eventId)-snooze",
            content: content,
            trigger: trigger
        )

        center.add(request)
    }

    // MARK: - UNUserNotificationCenterDelegate

    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        didReceive response: UNNotificationResponse
    ) async {
        let userInfo = response.notification.request.content.userInfo
        let eventId = userInfo["eventId"] as? String
        let meetingURL = userInfo["meetingURL"] as? String

        switch response.actionIdentifier {
        case Self.snooze3Action:
            reschedule(eventId: eventId, meetingURL: meetingURL, minutes: 3)

        case Self.snooze5Action:
            reschedule(eventId: eventId, meetingURL: meetingURL, minutes: 5)

        case Self.snooze10Action:
            reschedule(eventId: eventId, meetingURL: meetingURL, minutes: 10)

        case Self.joinMeetingAction:
            if let urlString = meetingURL, !urlString.isEmpty,
               let url = URL(string: urlString) {
                await MainActor.run {
                    NSWorkspace.shared.open(url)
                }
            }

        case UNNotificationDefaultActionIdentifier:
            // User tapped notification body - could open app to event
            break

        case Self.dismissAction:
            // User dismissed - nothing to do
            break

        default:
            break
        }
    }

    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        willPresent notification: UNNotification
    ) async -> UNNotificationPresentationOptions {
        // Show notification even when app is in foreground
        return [.banner, .sound, .badge]
    }
}
```

Add file to Xcode project in Services group.
  </action>
  <verify>Build succeeds with NotificationService</verify>
  <done>NotificationService handles permission, scheduling with sound option, categories, snooze delegate actions</done>
</task>

<task type="auto">
  <name>Task 2: Initialize NotificationService on app launch</name>
  <files>ToEvent/ToEvent/ToEventApp.swift</files>
  <action>
In ToEventApp.swift, call NotificationService.setup() during app initialization.

Find the App struct and add setup call. If there's an init() method, add it there. Otherwise add one:

```swift
init() {
    NotificationService.shared.setup()
}
```

If init() already exists, just add the setup() call to it.

Also import UserNotifications at the top if not already present.
  </action>
  <verify>Build succeeds; NotificationService.setup() called on app launch</verify>
  <done>NotificationService initialized and delegate set on app launch</done>
</task>

</tasks>

<verification>
1. Build: `xcodebuild -project ToEvent/ToEvent.xcodeproj -scheme ToEvent build`
2. NotificationService.swift exists in Services
3. NotificationService.setup() called in ToEventApp.init()
4. Notification categories registered with snooze actions
5. scheduleReminder accepts soundOption parameter
</verification>

<success_criteria>
- NotificationService singleton with UNUserNotificationCenter
- Permission request method returns Bool
- Category registered with 3min/5min/10min snooze + join actions
- scheduleReminder() accepts soundOption parameter and maps to UNNotificationSound
- Delegate handles snooze by rescheduling with time interval
- Join action opens meeting URL in browser
- Service initialized on app launch
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06-meeting-links-notifications/06-02-SUMMARY.md`
</output>
