---
phase: 06-meeting-links-notifications
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - ToEvent/ToEvent/Services/TravelTimeService.swift
  - ToEvent/ToEvent/Extensions/Event+TravelTime.swift
  - ToEvent/ToEvent/Extensions/Array+Conflicts.swift
  - ToEvent/ToEvent/State/AppState.swift
  - ToEvent/ToEvent/Views/EventRowView.swift
  - ToEvent/ToEvent/Views/EventDetailView.swift
autonomous: true

must_haves:
  truths:
    - "Events with locations show estimated travel time"
    - "Leave time is calculated based on travel time + event start"
    - "Travel time and leave time are displayed in EventDetailView"
    - "Overlapping events are detected and flagged"
    - "Conflict warnings appear in the UI"
  artifacts:
    - path: "ToEvent/ToEvent/Services/TravelTimeService.swift"
      provides: "MKDirections ETA calculation"
      exports: ["TravelTimeService"]
    - path: "ToEvent/ToEvent/Extensions/Array+Conflicts.swift"
      provides: "Conflict detection for event arrays"
      contains: "var conflicts"
  key_links:
    - from: "AppState.swift"
      to: "Array+Conflicts.swift"
      via: "events.conflicts computed property"
      pattern: "events\\.conflicts"
    - from: "EventRowView.swift"
      to: "AppState.swift"
      via: "shows conflict indicator"
    - from: "EventDetailView.swift"
      to: "TravelTimeService.swift"
      via: "displays travel time and leave time"
      pattern: "TravelTimeService.*calculateTravelTime"
---

<objective>
Add travel time calculation using MapKit and conflict detection for overlapping events.

Purpose: Implements ACTN-04 (travel time awareness) and SYST-04 (conflict warnings).
Output: TravelTimeService, Event travel time extension, conflict detection, UI indicators, travel time display in EventDetailView
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-meeting-links-notifications/06-RESEARCH.md
@.planning/phases/06-meeting-links-notifications/06-01-SUMMARY.md
@ToEvent/ToEvent/State/AppState.swift
@ToEvent/ToEvent/Views/EventRowView.swift
@ToEvent/ToEvent/Views/EventDetailView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TravelTimeService</name>
  <files>ToEvent/ToEvent/Services/TravelTimeService.swift</files>
  <action>
Create TravelTimeService for calculating ETA using MapKit:

```swift
import Foundation
import MapKit
import CoreLocation

enum TravelTimeError: Error {
    case locationNotAvailable
    case directionsNotAvailable
    case noRoute
}

final class TravelTimeService {
    static let shared = TravelTimeService()

    private let geocoder = CLGeocoder()
    private var cache: [String: TimeInterval] = [:]

    private init() {}

    /// Calculate travel time from current location to destination address
    /// Returns travel time in seconds, or nil if calculation fails
    func calculateTravelTime(to address: String) async -> TimeInterval? {
        // Check cache first
        if let cached = cache[address] {
            return cached
        }

        // Geocode the address
        guard let destination = await geocodeAddress(address) else {
            return nil
        }

        // Calculate ETA
        do {
            let travelTime = try await calculateETA(to: destination)
            cache[address] = travelTime
            return travelTime
        } catch {
            return nil
        }
    }

    private func geocodeAddress(_ address: String) async -> CLLocation? {
        do {
            let placemarks = try await geocoder.geocodeAddressString(address)
            return placemarks.first?.location
        } catch {
            return nil
        }
    }

    private func calculateETA(to destination: CLLocation) async throws -> TimeInterval {
        let request = MKDirections.Request()
        request.source = MKMapItem.forCurrentLocation()
        request.destination = MKMapItem(
            placemark: MKPlacemark(coordinate: destination.coordinate)
        )
        request.transportType = .automobile

        let directions = MKDirections(request: request)
        let response = try await directions.calculateETA()
        return response.expectedTravelTime
    }

    /// Calculate leave time for an event
    /// Returns the time user should leave to arrive on time
    func calculateLeaveTime(for event: Event) async -> Date? {
        guard let location = event.location, !location.isEmpty else {
            return nil
        }

        guard let travelTime = await calculateTravelTime(to: location) else {
            return nil
        }

        // Add 5 minute buffer
        let buffer: TimeInterval = 5 * 60
        return event.startDate.addingTimeInterval(-(travelTime + buffer))
    }

    /// Format travel time for display (e.g., "25 min" or "1h 15min")
    func formatTravelTime(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds / 60)
        if minutes < 60 {
            return "\(minutes) min"
        } else {
            let hours = minutes / 60
            let remainingMinutes = minutes % 60
            if remainingMinutes == 0 {
                return "\(hours)h"
            } else {
                return "\(hours)h \(remainingMinutes)min"
            }
        }
    }

    /// Clear the cache (useful when location changes significantly)
    func clearCache() {
        cache.removeAll()
    }
}
```

Add file to Xcode project in Services group.
  </action>
  <verify>Build succeeds with TravelTimeService</verify>
  <done>TravelTimeService calculates ETA and leave time using MKDirections</done>
</task>

<task type="auto">
  <name>Task 2: Create Array+Conflicts extension</name>
  <files>ToEvent/ToEvent/Extensions/Array+Conflicts.swift</files>
  <action>
Create extension for detecting overlapping events:

```swift
import Foundation

extension Array where Element == Event {
    /// Find all pairs of overlapping events
    var conflicts: [(Event, Event)] {
        var result: [(Event, Event)] = []
        let timedEvents = filter { !$0.isAllDay }

        for i in 0..<timedEvents.count {
            for j in (i + 1)..<timedEvents.count {
                let a = timedEvents[i]
                let b = timedEvents[j]

                // Check if intervals overlap
                // a.start < b.end AND b.start < a.end
                if a.startDate < b.endDate && b.startDate < a.endDate {
                    result.append((a, b))
                }
            }
        }

        return result
    }

    /// Get IDs of all events that have conflicts
    var conflictingEventIDs: Set<String> {
        var ids = Set<String>()
        for (a, b) in conflicts {
            ids.insert(a.id)
            ids.insert(b.id)
        }
        return ids
    }

    /// Check if a specific event has conflicts
    func hasConflict(_ event: Event) -> Bool {
        conflictingEventIDs.contains(event.id)
    }
}
```

Add file to Xcode project in Extensions group.
  </action>
  <verify>Build succeeds with Array+Conflicts extension</verify>
  <done>Event arrays can detect conflicts with conflicts, conflictingEventIDs, hasConflict()</done>
</task>

<task type="auto">
  <name>Task 3: Add conflict tracking to AppState and UI indicators</name>
  <files>ToEvent/ToEvent/State/AppState.swift, ToEvent/ToEvent/Views/EventRowView.swift</files>
  <action>
**AppState.swift:**

Add computed property for conflicting events after the `timedEvents` property:

```swift
var conflictingEventIDs: Set<String> {
    events.conflictingEventIDs
}

func hasConflict(_ event: Event) -> Bool {
    conflictingEventIDs.contains(event.id)
}
```

**EventRowView.swift:**

Update rowContent to show conflict indicator. Add a warning icon after the calendar color circle if event has conflict:

In the HStack at the start of rowContent, after the Circle():

```swift
HStack(spacing: 8) {
    Circle()
        .fill(Color(cgColor: event.calendarColor))
        .frame(width: 8, height: 8)

    // Conflict indicator
    if appState.hasConflict(event) {
        Image(systemName: "exclamationmark.triangle.fill")
            .font(.caption2)
            .foregroundColor(.orange)
            .help("Overlaps with another event")
    }

    // ... rest of content
}
```

The warning icon should appear between the calendar dot and the title, but only when the event has a conflict.
  </action>
  <verify>Build succeeds; events with overlapping times show orange warning triangle</verify>
  <done>AppState exposes conflictingEventIDs; EventRowView shows warning indicator for conflicts</done>
</task>

<task type="auto">
  <name>Task 4: Display travel time and leave time in EventDetailView</name>
  <files>ToEvent/ToEvent/Views/EventDetailView.swift</files>
  <action>
Update EventDetailView to show travel time and leave time for events with locations.

Add state for travel time calculation:

```swift
@State private var travelTime: TimeInterval?
@State private var leaveTime: Date?
@State private var isLoadingTravelTime = false
```

Add a section to display travel info after the location section. Only show if event has a location:

```swift
// Travel time info (after location section)
if let location = event.location, !location.isEmpty {
    HStack(alignment: .top) {
        Image(systemName: "car")
            .foregroundColor(.secondary)
            .frame(width: 20)

        VStack(alignment: .leading, spacing: 4) {
            if isLoadingTravelTime {
                HStack(spacing: 4) {
                    ProgressView()
                        .scaleEffect(0.7)
                    Text("Calculating travel time...")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            } else if let travelTime = travelTime {
                Text("Travel: \(TravelTimeService.shared.formatTravelTime(travelTime))")
                    .font(.callout)

                if let leaveTime = leaveTime {
                    let formatter = DateFormatter()
                    formatter.timeStyle = .short
                    Text("Leave by \(formatter.string(from: leaveTime))")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            } else {
                Text("Travel time unavailable")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
    }
}
```

Add .task modifier to trigger travel time calculation when view appears:

```swift
.task {
    if let location = event.location, !location.isEmpty {
        isLoadingTravelTime = true
        travelTime = await TravelTimeService.shared.calculateTravelTime(to: location)
        leaveTime = await TravelTimeService.shared.calculateLeaveTime(for: event)
        isLoadingTravelTime = false
    }
}
```

This ensures travel time is calculated asynchronously when the detail view opens, and displays both the estimated travel time and the recommended leave time.
  </action>
  <verify>Build succeeds; EventDetailView shows travel time and leave time for events with locations</verify>
  <done>EventDetailView displays calculated travel time and leave time from TravelTimeService</done>
</task>

</tasks>

<verification>
1. Build: `xcodebuild -project ToEvent/ToEvent.xcodeproj -scheme ToEvent build`
2. TravelTimeService.swift exists in Services
3. Array+Conflicts.swift exists in Extensions
4. AppState has conflictingEventIDs and hasConflict() method
5. EventRowView shows warning icon for conflicting events
6. EventDetailView shows travel time and leave time for events with locations
</verification>

<success_criteria>
- TravelTimeService calculates travel time using MKDirections
- TravelTimeService caches results to avoid repeated API calls
- TravelTimeService has formatTravelTime() for display
- Array+Conflicts detects overlapping timed events
- AppState exposes conflict detection via hasConflict()
- EventRowView shows orange warning triangle for conflicting events
- **EventDetailView displays travel time and leave time for events with locations**
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/06-meeting-links-notifications/06-04-SUMMARY.md`
</output>
