---
phase: 05-external-calendar-apis
plan: 05
type: execute
wave: 3
depends_on: ["05-03", "05-04"]
files_modified:
  - ToEvent/ToEvent/Services/CalendarProviderManager.swift
  - ToEvent/ToEvent/State/AppState.swift
  - ToEvent/ToEvent/Services/EventCacheService.swift
autonomous: true
user_setup: []

must_haves:
  truths:
    - "CalendarProviderManager aggregates events from all providers"
    - "AppState.events includes events from local + external sources"
    - "Events are cached for offline access"
    - "Auth expiry prompts user re-login in settings"
  artifacts:
    - path: "ToEvent/ToEvent/Services/CalendarProviderManager.swift"
      provides: "Multi-provider event aggregation"
      exports: ["CalendarProviderManager"]
    - path: "ToEvent/ToEvent/Services/EventCacheService.swift"
      provides: "JSON-based event cache for offline"
      exports: ["EventCacheService"]
  key_links:
    - from: "ToEvent/ToEvent/State/AppState.swift"
      to: "CalendarProviderManager"
      via: "refreshEvents() delegation"
      pattern: "CalendarProviderManager\\.shared"
    - from: "ToEvent/ToEvent/Services/CalendarProviderManager.swift"
      to: "CalendarProvider"
      via: "provider array iteration"
      pattern: "providers.*forEach|for.*in.*providers"
---

<objective>
Integrate multi-provider architecture into AppState with event caching.

Purpose: Aggregate events from local and external calendars into unified event list. Cache external events for offline access. Handle auth expiry gracefully.

Output: CalendarProviderManager for multi-source aggregation, EventCacheService for offline support, AppState updated to use provider-based fetching.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-external-calendar-apis/05-RESEARCH.md

@.planning/phases/05-external-calendar-apis/05-01-SUMMARY.md
@.planning/phases/05-external-calendar-apis/05-03-SUMMARY.md
@.planning/phases/05-external-calendar-apis/05-04-SUMMARY.md

@ToEvent/ToEvent/State/AppState.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EventCacheService</name>
  <files>
    ToEvent/ToEvent/Services/EventCacheService.swift
  </files>
  <action>
Create EventCacheService.swift for offline event storage:

```swift
final class EventCacheService {
    static let shared = EventCacheService()

    private let cacheDirectory: URL
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()

    func cacheEvents(_ events: [Event], for accountId: String) throws
    func loadCachedEvents(for accountId: String) -> [Event]
    func clearCache(for accountId: String)
    func clearAllCaches()
}
```

Storage:
- Directory: ~/Library/Caches/com.toevent/events/
- One JSON file per account: {accountId}.json
- Event struct needs Codable conformance (add if missing)

Cache structure:
```swift
struct CachedEvents: Codable {
    let accountId: String
    let cachedAt: Date
    let events: [Event]
}
```

Cache invalidation:
- Events older than 24 hours are stale (log warning but still return)
- clearCache removes file for account
- clearAllCaches removes all files in cache directory

Note: Event.calendarColor is CGColor which is not Codable. Add:
- Extension to encode CGColor as hex string
- Extension to decode hex string back to CGColor
  </action>
  <verify>Build succeeds. Can cache and retrieve test events.</verify>
  <done>EventCacheService stores events as JSON. Events survive app restart.</done>
</task>

<task type="auto">
  <name>Task 2: Create CalendarProviderManager</name>
  <files>
    ToEvent/ToEvent/Services/CalendarProviderManager.swift
  </files>
  <action>
Create CalendarProviderManager.swift:

```swift
final class CalendarProviderManager: ObservableObject {
    static let shared = CalendarProviderManager()

    @Published private(set) var providers: [CalendarProvider] = []
    @Published private(set) var expiredAccounts: [CalendarAccount] = []

    private let localProvider = LocalCalendarProvider()

    init() {
        loadProviders()
    }

    func loadProviders() {
        providers = [localProvider]

        for account in AuthService.shared.accounts {
            switch account.providerType {
            case .google:
                providers.append(GoogleCalendarProvider(account: account))
            case .outlook:
                providers.append(OutlookCalendarProvider(account: account))
            case .local:
                break // Already added
            }
        }
    }

    func addProvider(for account: CalendarAccount) {
        // Add new provider to list
    }

    func removeProvider(for accountId: String) {
        // Remove provider and clear cache
    }

    func fetchAllEvents(from: Date, to: Date, enabledCalendarIDs: Set<String>?) async -> [Event] {
        var allEvents: [Event] = []
        var newExpiredAccounts: [CalendarAccount] = []

        for provider in providers {
            do {
                let calendarIDs = enabledCalendarIDs.map { Array($0) }
                let events = try await provider.fetchEvents(from: from, to: to, calendarIDs: calendarIDs)
                allEvents.append(contentsOf: events)

                // Cache external events
                if provider.providerType != .local {
                    try? EventCacheService.shared.cacheEvents(events, for: provider.account.id)
                }
            } catch {
                if isAuthExpiredError(error) {
                    newExpiredAccounts.append(provider.account)
                    // Load from cache as fallback
                    let cached = EventCacheService.shared.loadCachedEvents(for: provider.account.id)
                    allEvents.append(contentsOf: cached)
                } else {
                    // Other errors: log and use cache
                    let cached = EventCacheService.shared.loadCachedEvents(for: provider.account.id)
                    allEvents.append(contentsOf: cached)
                }
            }
        }

        DispatchQueue.main.async {
            self.expiredAccounts = newExpiredAccounts
        }

        return allEvents.sorted { $0.startDate < $1.startDate }
    }

    func fetchAllCalendars() async -> [CalendarInfo] {
        // Aggregate calendars from all providers
    }

    private func isAuthExpiredError(_ error: Error) -> Bool {
        // Check for 401-related errors from Google/Outlook providers
    }
}
```

Thread safety:
- Network calls run on background
- UI updates dispatch to main queue
  </action>
  <verify>Build succeeds. CalendarProviderManager.shared.providers includes localProvider.</verify>
  <done>CalendarProviderManager aggregates events from multiple providers with cache fallback.</done>
</task>

<task type="auto">
  <name>Task 3: Update AppState to use CalendarProviderManager</name>
  <files>
    ToEvent/ToEvent/State/AppState.swift
  </files>
  <action>
Update AppState.refreshEvents() to use CalendarProviderManager:

```swift
func refreshEvents() {
    Task {
        let now = Date()
        let endDate = now.addingTimeInterval(lookahead)
        let events = await CalendarProviderManager.shared.fetchAllEvents(
            from: now,
            to: endDate,
            enabledCalendarIDs: enabledCalendarIDs
        )

        // Apply calendar priority sorting
        let sortedEvents = events.sorted { a, b in
            if a.startDate != b.startDate {
                return a.startDate < b.startDate
            }
            let aIndex = calendarPriority.firstIndex(of: a.calendarID) ?? Int.max
            let bIndex = calendarPriority.firstIndex(of: b.calendarID) ?? Int.max
            return aIndex < bIndex
        }

        await MainActor.run {
            self.events = sortedEvents
            self.nextEvent = sortedEvents.first
        }
    }
}
```

Add property for expired accounts (for UI to show re-auth prompt):
```swift
var accountsNeedingReauth: [CalendarAccount] {
    CalendarProviderManager.shared.expiredAccounts
}
```

Observe CalendarProviderManager.expiredAccounts:
- When non-empty, UI can show indicator in settings

Keep existing CalendarService integration:
- CalendarService still handles EventKit notifications
- lastRefresh triggers refreshEvents() which now uses CalendarProviderManager
  </action>
  <verify>Build succeeds. App launches. Local events still appear in menu bar.</verify>
  <done>AppState uses CalendarProviderManager. Events from all sources appear in unified list.</done>
</task>

</tasks>

<verification>
- [ ] `xcodebuild build` passes
- [ ] App launches without crash
- [ ] Local calendar events still appear
- [ ] EventCacheService creates cache files in ~/Library/Caches/
- [ ] CalendarProviderManager.providers is non-empty
</verification>

<success_criteria>
CalendarProviderManager aggregates events from all registered providers.
EventCacheService provides offline fallback for external events.
AppState.events includes local and external events.
Auth expiry captured in expiredAccounts for UI display.
Existing local calendar functionality unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/05-external-calendar-apis/05-05-SUMMARY.md`
</output>
