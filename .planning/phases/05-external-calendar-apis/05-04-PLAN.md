---
phase: 05-external-calendar-apis
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - ToEvent/ToEvent/Services/OutlookCalendarProvider.swift
  - ToEvent/ToEvent/Models/MicrosoftAPIModels.swift
autonomous: true
user_setup: []

must_haves:
  truths:
    - "OutlookCalendarProvider implements CalendarProvider protocol"
    - "Events fetched from Microsoft Graph appear with source .outlook"
    - "Calendar list fetched includes color and title"
    - "401 errors trigger re-auth prompt"
  artifacts:
    - path: "ToEvent/ToEvent/Services/OutlookCalendarProvider.swift"
      provides: "Microsoft Graph Calendar API implementation"
      exports: ["OutlookCalendarProvider"]
    - path: "ToEvent/ToEvent/Models/MicrosoftAPIModels.swift"
      provides: "Codable models for Microsoft Graph responses"
      exports: ["MicrosoftCalendarsResponse", "MicrosoftEventsResponse", "MicrosoftEvent", "MicrosoftCalendar"]
  key_links:
    - from: "ToEvent/ToEvent/Services/OutlookCalendarProvider.swift"
      to: "https://graph.microsoft.com/v1.0"
      via: "URLSession requests"
      pattern: "graph\\.microsoft\\.com"
    - from: "ToEvent/ToEvent/Services/OutlookCalendarProvider.swift"
      to: "AuthService"
      via: "credential retrieval"
      pattern: "AuthService\\.shared\\.getCredentials"
---

<objective>
Implement Microsoft Outlook/365 calendar provider.

Purpose: Fetch calendars and events from Microsoft Graph API. Implements CalendarProvider protocol. Uses stored OAuth credentials from AuthService.

Output: OutlookCalendarProvider that fetches real data from Microsoft Graph, MicrosoftAPIModels for JSON parsing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-external-calendar-apis/05-RESEARCH.md

@.planning/phases/05-external-calendar-apis/05-01-SUMMARY.md
@.planning/phases/05-external-calendar-apis/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Microsoft Graph API response models</name>
  <files>
    ToEvent/ToEvent/Models/MicrosoftAPIModels.swift
  </files>
  <action>
Create MicrosoftAPIModels.swift with Codable structs matching Microsoft Graph API responses:

```swift
// GET /me/calendars response
struct MicrosoftCalendarsResponse: Codable {
    let value: [MicrosoftCalendar]
}

struct MicrosoftCalendar: Codable {
    let id: String
    let name: String
    let color: String?  // "auto", "lightBlue", "lightGreen", etc.
    let isDefaultCalendar: Bool?
}

// GET /me/calendar/calendarView response
struct MicrosoftEventsResponse: Codable {
    let value: [MicrosoftEvent]?
}

struct MicrosoftEvent: Codable {
    let id: String
    let subject: String?
    let start: MicrosoftDateTime
    let end: MicrosoftDateTime
    let isAllDay: Bool?
    let isCancelled: Bool?
}

struct MicrosoftDateTime: Codable {
    let dateTime: String  // "2024-01-15T09:00:00.0000000"
    let timeZone: String  // "Pacific Standard Time"
}
```

Conversion extensions:
- MicrosoftCalendar.toCalendarInfo(accountId:) -> CalendarInfo
- MicrosoftEvent.toEvent(calendarId:, calendarTitle:, calendarColor:, accountId:) -> Event

Color handling:
- Microsoft returns color names not hex
- Map to predefined CGColors: lightBlue -> system blue, lightGreen -> system green, etc.
- Default to gray for "auto" or unknown
  </action>
  <verify>Build succeeds. Models can be instantiated.</verify>
  <done>MicrosoftAPIModels compile. Can decode sample JSON responses.</done>
</task>

<task type="auto">
  <name>Task 2: Create OutlookCalendarProvider</name>
  <files>
    ToEvent/ToEvent/Services/OutlookCalendarProvider.swift
  </files>
  <action>
Create OutlookCalendarProvider.swift implementing CalendarProvider:

```swift
final class OutlookCalendarProvider: CalendarProvider {
    let providerType: CalendarProviderType = .outlook
    let account: CalendarAccount

    private var credentials: OAuthCredentials?
    private let baseURL = "https://graph.microsoft.com/v1.0"

    init(account: CalendarAccount) {
        self.account = account
        self.credentials = AuthService.shared.getCredentials(for: account.id)
    }

    var isAuthenticated: Bool {
        credentials != nil && !(credentials?.isExpired ?? true)
    }

    func authenticate(presentingWindow: NSWindow?) async throws {
        guard let window = presentingWindow else {
            throw OutlookCalendarError.noWindow
        }
        credentials = try await AuthService.shared.startOAuthFlow(for: .outlook, presentingWindow: window)
    }

    func fetchCalendars() async throws -> [CalendarInfo] {
        let data = try await request(path: "/me/calendars")
        let response = try JSONDecoder().decode(MicrosoftCalendarsResponse.self, from: data)
        return response.value.map { $0.toCalendarInfo(accountId: account.id) }
    }

    func fetchEvents(from: Date, to: Date, calendarIDs: [String]?) async throws -> [Event] {
        // Microsoft Graph uses calendarView for time-range queries
        let formatter = ISO8601DateFormatter()
        let queryItems = [
            URLQueryItem(name: "startDateTime", value: formatter.string(from: from)),
            URLQueryItem(name: "endDateTime", value: formatter.string(from: to))
        ]

        var allEvents: [Event] = []
        let calendars = try await fetchCalendars()
        let targetCalendars = calendarIDs.map { ids in
            calendars.filter { ids.contains($0.id) }
        } ?? calendars

        for calendar in targetCalendars {
            let path = "/me/calendars/\(calendar.id)/calendarView"
            let data = try await request(path: path, queryItems: queryItems)
            let response = try JSONDecoder().decode(MicrosoftEventsResponse.self, from: data)
            let events = (response.value ?? [])
                .filter { !($0.isCancelled ?? false) }
                .map { $0.toEvent(calendarId: calendar.id, calendarTitle: calendar.title, calendarColor: calendar.color, accountId: account.id) }
            allEvents.append(contentsOf: events)
        }

        return allEvents.sorted { $0.startDate < $1.startDate }
    }

    func signOut() async {
        try? AuthService.shared.deleteAccount(account.id)
        credentials = nil
    }

    private func request(path: String, queryItems: [URLQueryItem] = []) async throws -> Data
}
```

Request method:
- Same pattern as GoogleCalendarProvider
- Authorization: Bearer {token}
- Handle 401 -> authExpired
- Handle 429 -> rateLimited (respect Retry-After header if present)

DateTime parsing:
- Microsoft returns local time with timezone name
- Convert to Date using TimeZone(identifier:) or abbreviation mapping

Error enum:
```swift
enum OutlookCalendarError: Error {
    case noWindow
    case notAuthenticated
    case authExpired
    case rateLimited(retryAfter: Int?)
    case networkError(Error)
    case invalidResponse
}
```
  </action>
  <verify>Build succeeds. OutlookCalendarProvider instantiates with a mock CalendarAccount.</verify>
  <done>OutlookCalendarProvider implements CalendarProvider. Ready for integration once OAuth configured.</done>
</task>

</tasks>

<verification>
- [ ] `xcodebuild build` passes
- [ ] MicrosoftAPIModels can decode sample JSON
- [ ] OutlookCalendarProvider compiles and conforms to CalendarProvider
- [ ] Error handling covers 401 and 429
</verification>

<success_criteria>
OutlookCalendarProvider implements CalendarProvider protocol.
API models correctly decode Microsoft Graph responses.
Events have source .outlook and proper accountId.
Auth expiry triggers error (handled by caller).
</success_criteria>

<output>
After completion, create `.planning/phases/05-external-calendar-apis/05-04-SUMMARY.md`
</output>
