---
phase: 05-external-calendar-apis
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ToEvent/ToEvent/Services/KeychainService.swift
  - ToEvent/ToEvent/Services/AuthService.swift
  - ToEvent/ToEvent.xcodeproj/project.pbxproj
  - ToEvent/ToEvent/ToEvent.entitlements
autonomous: true
user_setup:
  - service: google
    why: "Google Calendar API OAuth"
    env_vars: []
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (iOS app type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials"
      - task: "Enable Google Calendar API"
        location: "Google Cloud Console -> APIs & Services -> Library"
  - service: microsoft
    why: "Microsoft Graph API OAuth"
    env_vars: []
    dashboard_config:
      - task: "Register application"
        location: "Azure Portal -> App registrations"
      - task: "Add Calendars.Read permission"
        location: "Azure Portal -> App registrations -> API permissions"

must_haves:
  truths:
    - "OAuth tokens stored securely in Keychain"
    - "AuthService can initiate OAuth flow via ASWebAuthenticationSession"
    - "Tokens can be retrieved by account ID"
    - "Tokens can be deleted for sign-out"
  artifacts:
    - path: "ToEvent/ToEvent/Services/KeychainService.swift"
      provides: "Keychain wrapper for token storage"
      exports: ["KeychainService"]
    - path: "ToEvent/ToEvent/Services/AuthService.swift"
      provides: "OAuth flow orchestration"
      exports: ["AuthService"]
    - path: "ToEvent/ToEvent/ToEvent.entitlements"
      provides: "Keychain sharing entitlement"
      contains: "keychain-access-groups"
  key_links:
    - from: "ToEvent/ToEvent/Services/AuthService.swift"
      to: "ASWebAuthenticationSession"
      via: "import AuthenticationServices"
      pattern: "ASWebAuthenticationSession"
    - from: "ToEvent/ToEvent/Services/AuthService.swift"
      to: "KeychainService"
      via: "token persistence"
      pattern: "KeychainService.*save|load|delete"
---

<objective>
Implement Keychain storage and OAuth authentication infrastructure.

Purpose: Secure token storage and centralized OAuth flow handling. ASWebAuthenticationSession provides system browser sheet for OAuth (required by Google, works for Microsoft). KeychainService abstracts Keychain API complexity.

Output: KeychainService for token CRUD, AuthService for OAuth flow coordination, Keychain entitlement added.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-external-calendar-apis/05-RESEARCH.md

@ToEvent/ToEvent/Models/OAuthCredentials.swift (from 05-01)
@ToEvent/ToEvent/Models/CalendarProviderType.swift (from 05-01)
@ToEvent/ToEvent/Models/CalendarAccount.swift (from 05-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KeychainService</name>
  <files>
    ToEvent/ToEvent/Services/KeychainService.swift
  </files>
  <action>
Create KeychainService.swift using native Security framework (avoid Valet dependency for now - simpler):

```swift
import Foundation
import Security

final class KeychainService {
    static let shared = KeychainService()
    private let service = "com.toevent.oauth"

    func save(_ credentials: OAuthCredentials, for accountId: String) throws
    func load(for accountId: String) -> OAuthCredentials?
    func delete(for accountId: String) throws
    func listAccountIds() -> [String]
}
```

Implementation notes:
- Use kSecClassGenericPassword for storing JSON-encoded OAuthCredentials
- Account identifier as kSecAttrAccount
- Service name as kSecAttrService
- Encode/decode OAuthCredentials using JSONEncoder/JSONDecoder
- Handle common errors: errSecItemNotFound, errSecDuplicateItem
- For listAccountIds, query with kSecMatchLimit = kSecMatchLimitAll and kSecReturnAttributes = true

Error handling:
- Wrap OSStatus errors in a custom KeychainError enum
- Log errors but don't crash
  </action>
  <verify>Build succeeds. Unit test manually: save credentials, load them back, delete them.</verify>
  <done>KeychainService compiles. Can save/load/delete OAuthCredentials by account ID.</done>
</task>

<task type="auto">
  <name>Task 2: Create AuthService with ASWebAuthenticationSession</name>
  <files>
    ToEvent/ToEvent/Services/AuthService.swift
  </files>
  <action>
Create AuthService.swift:

```swift
import AuthenticationServices
import AppKit

final class AuthService: NSObject, ObservableObject {
    static let shared = AuthService()

    @Published private(set) var accounts: [CalendarAccount] = []

    func startOAuthFlow(
        for provider: CalendarProviderType,
        presentingWindow: NSWindow
    ) async throws -> OAuthCredentials

    func loadStoredAccounts()
    func getCredentials(for accountId: String) -> OAuthCredentials?
    func deleteAccount(_ accountId: String) throws
}

extension AuthService: ASWebAuthenticationPresentationContextProviding {
    func presentationAnchor(for session: ASWebAuthenticationSession) -> ASPresentationAnchor
}
```

Implementation:
- startOAuthFlow builds auth URL based on provider type:
  - Google: authorization_endpoint, scope calendar.readonly, response_type code
  - Microsoft: authorization_endpoint, scope Calendars.Read offline_access, response_type code
- Uses ASWebAuthenticationSession with callback URL scheme (toevent://)
- Extracts authorization code from callback URL
- Exchanges code for tokens (POST to token endpoint)
- Saves credentials via KeychainService
- Creates CalendarAccount and adds to accounts array
- Returns OAuthCredentials

OAuth URLs (constants in AuthService):
- Google auth: https://accounts.google.com/o/oauth2/v2/auth
- Google token: https://oauth2.googleapis.com/token
- Microsoft auth: https://login.microsoftonline.com/common/oauth2/v2.0/authorize
- Microsoft token: https://login.microsoftonline.com/common/oauth2/v2.0/token

Note: Client IDs will be needed. For now, use placeholder constants that user must replace:
```swift
private enum GoogleConfig {
    static let clientId = "YOUR_GOOGLE_CLIENT_ID"
    static let redirectUri = "toevent:/oauth/google"
    static let scope = "https://www.googleapis.com/auth/calendar.readonly"
}
private enum MicrosoftConfig {
    static let clientId = "YOUR_MICROSOFT_CLIENT_ID"
    static let redirectUri = "toevent://oauth/microsoft"
    static let scope = "Calendars.Read offline_access"
}
```

Error handling:
- AuthError enum for: userCancelled, invalidResponse, tokenExchangeFailed, networkError
  </action>
  <verify>Build succeeds. AuthService.shared instantiates without crash.</verify>
  <done>AuthService compiles. OAuth flow methods exist (actual auth requires client ID configuration).</done>
</task>

<task type="auto">
  <name>Task 3: Add Keychain entitlement and URL scheme</name>
  <files>
    ToEvent/ToEvent/ToEvent.entitlements
    ToEvent/ToEvent/Info.plist
  </files>
  <action>
Update ToEvent.entitlements:
- Add com.apple.security.keychain-access-groups with value ["$(AppIdentifierPrefix)com.toevent.oauth"]

Create or update Info.plist with URL scheme:
- Add CFBundleURLTypes array with:
  - CFBundleURLName: "OAuth Callback"
  - CFBundleURLSchemes: ["toevent"]

This enables:
1. Keychain storage for OAuth tokens
2. toevent:// URL scheme for OAuth callback

Note: If Info.plist doesn't exist, check if it's embedded in project.pbxproj or generated. For macOS SwiftUI apps, may need to add via Xcode project settings. Use xcodebuild or edit project.pbxproj if needed.
  </action>
  <verify>Build succeeds. Entitlements file contains keychain-access-groups.</verify>
  <done>Keychain entitlement added. URL scheme registered for OAuth callback.</done>
</task>

</tasks>

<verification>
- [ ] `xcodebuild build` passes
- [ ] KeychainService can store and retrieve test data
- [ ] AuthService instantiates without crash
- [ ] Entitlements include keychain access groups
- [ ] URL scheme toevent:// is registered
</verification>

<success_criteria>
KeychainService provides secure token storage.
AuthService orchestrates OAuth via ASWebAuthenticationSession.
Keychain entitlement enables token persistence.
URL scheme registered for OAuth callback.
</success_criteria>

<output>
After completion, create `.planning/phases/05-external-calendar-apis/05-02-SUMMARY.md`
</output>
